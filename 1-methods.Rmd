---
title: "Methods"
output:
  html_document:
    theme: flatly
    toc: true
    toc_depth: 2
---

# Methods

```{r, include=FALSE}
source("R/base.R")
source("R/helpers.R")
source("R/theme.R")
```

## Team structures

```{r team-structures-all, fig.width=2}
diagram_graphviz("team-structures-all", package = "evoteams")
```

## Landscapes

### Simple hill

```{r simple-hill}
limits <- -100:100
z <- expand.grid(x = limits, y = limits) %>%
  mutate(z = -x^2 - y^2) %>%
  spread(y, z)
z$x <- NULL  # bug! dplyr::select(-x) doesn't work
z <- as.matrix(z)

plot_ly(x = limits, y = limits, z = z) %>%
  add_surface()
```

## Types of time

The first assumption of these simulations is that there is no cost to handing the project off in the diachronic team. This means that if a diachronic team consists of two equally skilled individuals (two clones), it's performance is indistinguishable from the performance of one of those individuals working the whole time.

The second assumption is that there is no learning taking place over the course of the simulation. Individuals have the same skills at the beginning of the task as they do at the end of it. This assumption is also necessary in order for solo "teams" to be identical to diachronic teams consisting of two equally skilled individuals.

```{r time-plot, fig.keep="none"}
diachronic <- data_frame(
  strategy = "diachronic",
  calendar_hours = 0:100,
  labor_hours = calendar_hours
)

synchronic <- data_frame(
  strategy = "synchronic",
  calendar_hours = 0:50,
  labor_hours = calendar_hours * 2
)

time <- rbind(diachronic, synchronic)

axis_breaks <- c(0, 50, 100)
axis_labels <- axis_breaks

(gg_time <- ggplot(time, aes(calendar_hours, labor_hours)) +
  geom_line(aes(color = strategy), size = 1.2) +
  scale_x_continuous("calendar hours", breaks = axis_breaks, labels = axis_labels) +
  scale_y_continuous("labor hours", breaks = axis_breaks, labels = axis_labels) +
  scale_color_strategy +
  base_theme +
  theme(legend.position = "top"))
```

```{r min-steps, fig.keep="none"}
start_radius <- 100
hyp_distance <- sqrt(2 * start_radius^2)
synchronic_max <- sqrt(2 * 10^2)
synchronic_calendar_hours <- 50
diachronic_max <- sqrt(2 * 5^2)
diachronic_calendar_hours <- 100

min_steps <- data_frame(
  strategy = c("synchronic", "diachronic"),
  labor_hours_per_calendar_hour = c(2, 1),
  calendar_hours_to_peak = c(
    (hyp_distance/synchronic_max),
    (hyp_distance/diachronic_max)
  ),
  labor_hours_to_peak = calendar_hours_to_peak * labor_hours_per_calendar_hour)

gg_min_steps <- ggplot(min_steps) +
  geom_bar(stat = "identity") +
  scale_fill_manual(values = get_theme_color_values(c("blue", "green"))) +
  base_theme +
  theme(legend.position = "none",
        panel.grid.major.x = element_blank())

(gg_min_calendar <- gg_min_steps +
  aes(strategy, calendar_hours_to_peak, fill = strategy) +
  scale_y_continuous("calendar hours to peak (minimum)",
                     breaks = c(0, 10, 20)))

(gg_min_labor <- gg_min_steps +
  aes(strategy, labor_hours_to_peak, fill = strategy) +
  scale_y_continuous("labor hours to peak (minimum)",
                     breaks = c(0, 10, 20)))
```

```{r, fig.width = fig_width * 2}
grid.arrange(gg_time, gg_min_calendar, gg_min_labor, nrow = 1)
```

## Team abilities

```{r team-abilities}
teams <- get_experiment_data("differing-skills") %>%
  get_team_info() %>%
  gather(dimension, value, -c(team, player, team_id)) %>%
  recode_team() %>%
  select(-team)

legend_text <- data_frame(
  team_label_rev = factor(0, levels = 0:4),
  player = 1,
  value = c(0.1, 0.1),
  dimension = c("vision_x", "vision_y"),
  label = c("vision x", "vision y")
)

dodge_width <- position_dodge(width = 0.9)

ggplot(teams, aes(x = player, y = value, group = dimension)) +
  geom_bar(aes(fill = team_label_rev, alpha = dimension),
           stat = "identity", position = dodge_width) +
  facet_wrap("team_label_rev", nrow = 1) +
  geom_text(aes(label = label), data = legend_text, position = dodge_width,
         angle = 90, vjust = 0.4, hjust = 0) +
  scale_x_continuous(breaks = c(1, 2)) +
  scale_y_continuous("vision", breaks = 1:10, expand = c(0, 0)) +
  scale_fill_brewer(palette = "Set2") +
  scale_alpha_manual(values = c(0.5, 0.9)) +
  coord_cartesian(ylim = c(0, 9)) +
  base_theme +
  theme(
    legend.position = "none",
    panel.grid.major.x = element_blank(),
    panel.grid.minor.x = element_blank(),
    panel.grid.minor.y = element_blank()
  ) +
  labs(title = "Types of two agent teams varying in ability")
```

```{r, eval=FALSE}
ggplot(preds, aes(x = player, y = value, group = skill)) +
  geom_bar(aes(fill = team_ability, alpha = skill),
           stat = "identity", position = dodge_width) +
  facet_wrap("team_ability_label", nrow = 1) +
  scale_fill_brewer(palette = "Set2") +
  scale_alpha_manual(values = c(0.5, 0.9)) +
  geom_text(aes(label = label), data = legend_text, position = dodge_width,
            angle = 90, vjust = 0.5, hjust = 0) +
  base_theme +
  labs(title = "Types of two person teams varying in skill distribution")

t_range <- seq(0, 2 * pi, length.out = 100)
ellipse_x <- function(t, a, x0 = 0) x0 + a * cos(t)
ellipse_y <- function(t, b, y0 = 0) y0 + b * sin(t)

# Create a list of different area functions.
# Each fn returns data.frames with the same col names.
search_areas <- list(
  overlapping = function(player) {
    data_frame(
      player = player,
      team_ability = "identical",
      a = ellipse_x(t_range, 10),
      b = ellipse_y(t_range, 10)
    )
  },
  disjoint = function(player) {
    args <- list(
      x = list(a = 17, b = 3),
      y = list(a = 3, b = 17)
    )[[player]]
    data_frame(
      player = player,
      team_ability = "disjoint",
      a = ellipse_x(t_range, args[["a"]]),
      b = ellipse_y(t_range, args[["b"]])
    )
  },
  intersecting = function(player) {
    args <- list(
      x = list(a = 12, b = 8),
      y = list(a = 8, b = 12)
    )[[player]]
    data_frame(
      player = player,
      team_ability = "intersecting",
      a = ellipse_x(t_range, args[["a"]]),
      b = ellipse_y(t_range, args[["b"]])
    )
  }
)

spotlight_coords <- lapply(search_areas, function(area_fn) {
    # generate areas for players x and y and bind them together
    bind_rows(area_fn('x'), area_fn('y'))
  }) %>%
  # bind across area_fns
  bind_rows() %>%
  recode_team_abilities

legend_text <- data_frame(
  team_ability = "disjoint",
  player = c("x", "y"),
  a = c(10, 0),
  b = c(0, 10),
  label = c("player x", "player y"),
  angle = c(0, 90)
) %>%
  recode_team_abilities

ggplot(spotlight_coords, aes(a, b, group = player)) +
  geom_polygon(aes(fill = team_ability, alpha = player)) +
  facet_wrap("team_ability_label") +
  scale_fill_brewer(palette = "Set2") +
  scale_alpha_manual(values = c(0.5, 0.9)) +
  geom_text(aes(label = label, angle = angle), data = legend_text,
            vjust = 0.5) +
  base_theme +
  labs(title = "Abilities of two person teams as search areas in problem space")
```
